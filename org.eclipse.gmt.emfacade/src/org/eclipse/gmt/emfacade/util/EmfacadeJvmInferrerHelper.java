/*
 * generated by Xtext
 */
package org.eclipse.gmt.emfacade.util;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gmt.emfacade.EClassMapping;
import org.eclipse.gmt.emfacade.EClassifierMapping;
import org.eclipse.gmt.emfacade.EFeatureMapping;
import org.eclipse.gmt.emfacade.FacadeModel;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmFeature;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.TypesFactory;
import org.eclipse.xtext.common.types.util.Primitives;
import org.eclipse.xtext.common.types.util.Primitives.Primitive;
import org.eclipse.xtext.common.types.util.TypeReferences;

import com.google.inject.Inject;

public class EmfacadeJvmInferrerHelper {

	@Inject
	TypesFactory typesFactory;
	
	@Inject
	TypeReferences typeReferences;

	@Inject
	Primitives primitives;

	private EClassifierMapping getEClassifierMapping(FacadeModel model, EClassifier eClassifier) {
		for (EClassifierMapping eClassifierMapping : model.getClassifierMappings()) {
			if (eClassifierMapping.getEClassifier() == eClassifier) {
				return eClassifierMapping;
			}
		}
		return null;
	}

	public EClassifierMapping getEClassifierMapping(EClassifier eClassifier, EObject context) {
		FacadeModel model = Util.getContainerOfType(context, FacadeModel.class);
		EClassifierMapping eClassifierMapping = getEClassifierMapping(model, eClassifier);
		if (eClassifierMapping == null) {
			for (FacadeModel usedModel : model.getUsesFacadeModels()) {
				eClassifierMapping = getEClassifierMapping(usedModel, eClassifier);
				if (eClassifierMapping != null) {
					break;
				}
			}
		}
		return eClassifierMapping;
	}

	public JvmType getInferredJvmType(EClassifier eClassifier, EObject context, boolean asWrapper) {
		EClassifierMapping eClassifierMapping = getEClassifierMapping(eClassifier, context);
		if (eClassifierMapping != null) {
			return eClassifierMapping.getDeclaredType();
		}
		Class<?> instanceClass = eClassifier.getInstanceClass();
		if (instanceClass != null) {
			JvmTypeReference type = typeReferences.getTypeForName(instanceClass, context);
			return (asWrapper ? primitives.asWrapperTypeIfPrimitive(type) : type).getType();
		}
		if (eClassifier instanceof EEnum) {
			return typeReferences.getTypeForName(Integer.class, context).getType();
		} else if (eClassifier instanceof EDataType) {
			return typeReferences.getTypeForName(String.class, context).getType();
		}
		return null;
	}
	
	public JvmType getJClass(EFeatureMapping eFeatureMapping) {
		JvmType jClass = eFeatureMapping.getJClass();
		EClassifier eType = eFeatureMapping.getEFeature().getEType();
		if (jClass == null && eType != null) {
			jClass = getInferredJvmType(eType, eFeatureMapping, true);
		}
		return jClass;
	}
	
	public JvmType getEClass(EClassMapping eClassMapping) {
		EClassifier eClassifier = eClassMapping.getEClassifier();
		String basePackage = Util.getContainerOfType(eClassMapping, FacadeModel.class).getGenModel().getBasePackage();
		String eClassName = basePackage + "." + eClassifier.getEPackage().getName() + "." + eClassifier.getName();
		return getJvmTypeRef(eClassName, eClassMapping).getType();
	}

	public JvmGenericType getInferredJvmType(JvmGenericType interfaceType, JvmType... typeArguments) {
		JvmParameterizedTypeReference[] typeArgRefs = new JvmParameterizedTypeReference[typeArguments.length];
		for (int i = 0; i < typeArgRefs.length; i++) {
			JvmType type = typeArguments[i];
			if (type == null) {
				throw new NullPointerException("Type argument cannot be null");
			}
			typeArgRefs[i] = createJvmParameterizedTypeReference(type);
		}
		return getInferredJvmType(interfaceType, typeArgRefs);
	}

	private JvmGenericType getInferredJvmType(JvmGenericType interfaceType, JvmTypeReference... typeArguments) {
		if (interfaceType == null) {
			throw new NullPointerException("Interface type cannot be null");
		}
		// create inferred type, caller must provide type arguments and set the name
		JvmGenericType inferredType = typesFactory.createJvmGenericType();
		// link to supertype with proper type arguments
		JvmParameterizedTypeReference superTypeRef = typesFactory.createJvmParameterizedTypeReference();
		superTypeRef.setType(interfaceType);
		superTypeRef.getArguments().addAll(Arrays.asList(typeArguments));
		inferredType.getSuperTypes().add(superTypeRef);
		// add operation copies with resolved type parameters
		EcoreUtil.Copier copier = new ParameterizedCopier(inferredType);
		for (JvmFeature feature : inferredType.getAllFeatures()) {
			// copy operation that are not inherited from Object
			if (feature instanceof JvmOperation && (! "java.lang.Object".equals(feature.getDeclaringType().getQualifiedName()))) {
				JvmOperation copy = (JvmOperation) copier.copy(feature);
				copier.copyReferences();
				// standardize argument names
				setParameterNames(copy);
				inferredType.getMembers().add(copy);
			}
		}
		return inferredType;
	}

	private void setParameterNames(JvmOperation copy) {
		List<JvmFormalParameter> parameters = new ArrayList<JvmFormalParameter>(copy.getParameters());
		for (JvmFormalParameter parameter : parameters) {
			String name = parameter.getParameterType().getSimpleName();
			try {
				if (Primitive.valueOf(Util.upcaseFirst(name)) != null) {
					name += "Value";
				}
			} catch (IllegalArgumentException e) {
			}
			parameter.setName(Util.downcaseFirst(name));
		}
		Collections.sort(parameters, new Comparator<JvmFormalParameter>() {
			public int compare(JvmFormalParameter p1, JvmFormalParameter p2) {
				return p1.getName().compareTo(p2.getName());
			}
		});
		int count = 0;
		String lastName = null, namePattern = "{0}_{1}";
		for (int i = 0; i < parameters.size(); i++) {
			String name = parameters.get(i).getName();
			if (name.equals(lastName)) {
				if (count == 0) {
					parameters.get(i - 1).setName(MessageFormat.format(namePattern, name, (++count)));
				}
				parameters.get(i).setName(MessageFormat.format(namePattern, name, (++count)));
			} else {
				count = 0;
			}
			lastName = name;
		}
	}

	public static class ParameterizedCopier extends EcoreUtil.Copier {
		
		public ParameterizedCopier(JvmType type) {
			initMap(type);
		}
		public ParameterizedCopier(JvmTypeReference typeRef) {
			initMap(typeRef);
		}
	
		@Override
		public EObject get(Object key) {
			EObject value = super.get(key);
			while (containsKey(value)) {
				value = super.get(value);
			}
			return value;
		}

		private void initMap(JvmType type) {
			if (type instanceof JvmDeclaredType) {
				for (JvmTypeReference superTypeRef : ((JvmDeclaredType) type).getSuperTypes()) {
					initMap(superTypeRef);
				}
			}
		}
		private void initMap(JvmTypeReference typeRef) {
			JvmType type = typeRef.getType();
			if (type instanceof JvmGenericType && typeRef instanceof JvmParameterizedTypeReference) {
				EList<JvmTypeReference> typeArgs = ((JvmParameterizedTypeReference) typeRef).getArguments();
				EList<JvmTypeParameter> typeParams = ((JvmGenericType) type).getTypeParameters();
				for (int i = 0; i < typeParams.size(); i++) {
					JvmType argType = typeArgs.get(i).getType();
					put(typeParams.get(i), argType);
				}
			}
			initMap((JvmDeclaredType) type);
		}
	}

	public JvmTypeReference getJvmTypeRef(String typeName, EObject context) {
		return typeReferences.getTypeForName(typeName, context);
	}
	public JvmTypeReference getJvmTypeRef(Class<?> clazz, EObject context) {
		return typeReferences.getTypeForName(clazz, context);
	}

	public JvmParameterizedTypeReference createJvmParameterizedTypeReference(JvmType type) {
		if (type == null) {
			throw new NullPointerException("Type cannot be null");
		}
		JvmParameterizedTypeReference typeRef = typesFactory.createJvmParameterizedTypeReference();
		typeRef.setType(type);
		return typeRef;
	}
}
