// automatically generated by Xtext
grammar org.eclipse.gmt.Emfacade
// with org.eclipse.xtext.common.Terminals 
  with org.eclipse.xtext.xbase.Xbase

import "platform:/resource/org.eclipse.gmt.emfacade/model/emfacade.ecore" 

import "http://www.eclipse.org/xtext/common/JavaVMTypes" as java
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/emf/2002/GenModel" as genmodel
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

FacadeModel returns FacadeModel:
	{FacadeModel}
		'facade' genModel=[genmodel::GenPackage|QID] ('as' name = ID)? ('uses' usesFacadeModels += [FacadeModel|QID] (',' usesFacadeModels += [FacadeModel|QID])*)?
		(imports += ImportDirective)*
		(featureMappingStrategies += FeatureMappingStrategy)*
//		('package' basePackage=QID)?
		('feature-mapping-defaults' featureMappingDefaults = EFeatureMappingOptions)?
		(classifierMappings += EClassifierMapping)*
		('ePackages' '(' ePackages += [ecore::EPackage|EString] ( "," ePackages += [ecore::EPackage|EString])* ')' )?
    ;

MAPSTO: '->';
MAPSFROM: '<-';

EClassifierMapping: EClassMapping | EDataTypeMapping | EEnumMapping;

EClassMapping:
	'class' eClass = [ecore::EClass|QID] ('as' name = ID)? MAPSTO jClass = [java::JvmGenericType|QID]
	('feature-mapping-defaults' featureMappingDefaults = EFeatureMappingOptions)?
	('life-cycle' lifeCycleHandler = LifeCycleImplementation)?
//	('create-with' createExpression = XExpressionInClosure)?
//	('dispose-with' disposeExpression = XExpressionInClosure)?
	('map' featureMappings += EFeatureMapping (('map' | ',') featureMappings += EFeatureMapping)*)?
	('handle' eventHandlers += EventHandler)*
;

LifeCycleImplementation:
	('method' methodImplementations += InterfaceMethodImplementation)*
;

EventHandler:
	interfaceType = [java::JvmGenericType|QID]
	('method' methodImplementations += InterfaceMethodImplementation)*
;
InterfaceMethodImplementation:
	interfaceMethod = [java::JvmOperation|FID] ('as' name = ID)? (MAPSTO methodBody = XExpressionInClosure)?
;

EFeatureMapping:
	eFeature = [ecore::EStructuralFeature|ID] ('as' name = ID)? (MAPSTO jClass = [java::JvmGenericType|QID])?
	('using' options = EFeatureMappingOptions)?
	('method' methodImplementations += InterfaceMethodImplementation)*
;
EFeatureMappingOptions:
	{EFeatureMappingOptions} ('strategy' strategy = [FeatureMappingStrategy])?
;

EDataTypeMapping:
	'type' eDataType = [ecore::EDataType|QID] MAPSTO jClass = [java::JvmGenericType|QID]
		MAPSTO convertExpression = XExpression
;

EEnumMapping:
	'enum' eDataType = [ecore::EEnum|QID] MAPSTO jClass = [java::JvmGenericType|QID]
		(literalMappings += EEnumLiteralMapping)*
		MAPSTO convertExpression = XExpression
;

EEnumLiteralMapping:
	enumLiteral = [ecore::EEnumLiteral|ID] MAPSTO convertExpression = XExpression
;

FeatureMappingStrategy:
	 'strategy' implType = [java::JvmGenericType|QID] ('as' name = ID)? MAPSTO interfaceType = [java::JvmGenericType|QID]
	 ('map' patterns += FeatureMappingStrategyPattern)*
;

FeatureMappingStrategyPattern:
	featureName = NamePattern '<' (typeParameters += JvmTypeParameter (',' typeParameters += JvmTypeParameter)*)? '>'
	('method' methodPatterns += FeatureMappingStrategyMethodPattern)*
;
NamePattern returns ecore::EString: (ID | STRING);

JvmTypeParameter returns java::JvmTypeParameter:
	name = ID
;

FeatureMappingStrategyMethodPattern:
	strategyMethod = [java::JvmOperation|ID] MAPSTO targetMember = (JvmField | JvmOperation) MAPSTO targetBody = XExpressionInClosure
;

JvmField returns java::JvmField:
	'field' type = JvmTypeReference simpleName = ID
;

JvmOperation returns java::JvmOperation:
	returnType = JvmTypeReference simpleName = ID '(' (parameters += JvmFormalParameter (',' parameters += JvmFormalParameter)*)? ')'
;
JvmFormalParameter returns java::JvmFormalParameter:
	parameterType = JvmTypeReference name = ID
;

/*
strategy GetSetStrategy1 -> Association
	map X<M,ME,V,VE>
		method get(M) -> VE V.getX() -> v.getX()
		method set(M,ME) -> void V.setX(VE) -> v.setX(ve)
	map X<M,ME,V,VE>
		method get(M) -> VE V.x -> v.x
		method set(M,ME) -> VE V.x -> v.x = ve
 */

/*
NameTypePatternFMS returns FeatureMappingStrategy:
	 {NameTypePatternFMS}
	 'strategy' implType = [java::JvmGenericType|QID] 'for' interfaceType = [java::JvmGenericType|QID] 
	 '{'
	 	pattern = NameTypePattern
	 '}'
;

NameTypePattern:
	{NameTypePattern}
	'members' '{'
		(memberPatterns += MemberPattern)*
	'}'
;

MemberPattern: 
	typePattern = TypePattern namePattern = NamePattern (parameterListPattern = TypeListPattern)?
;

TypeListPattern:
	{TypeListPattern} '(' (parameterTypePatterns += TypePattern (','parameterTypePatterns += TypePattern)*)? ')'
;

TypePattern returns ecore::EString: (QID | '#' | '$' | STRING);
NamePattern returns ecore::EString: (ID | '$' | STRING)+;
 */

//

EString returns ecore::EString: STRING;

QID returns ecore::EString: ID ('.' ID)*;
FID returns ecore::EString: ID ('(' (ID (',' ID)*)? ')')?;

ImportDirective:
	'import' importedNamespace=(QualifiedNameWithWildcard | STRING)
;

QualifiedNameWithWildcard returns ecore::EString:  QID '.*'?;

//

XAdditiveExpression returns xbase::XExpression:
	XMultiplicativeExpression (=>({xbase::XBinaryOperation.leftOperand=current} feature=[java::JvmIdentifiableElement|OpAdd])
	rightOperand=XMultiplicativeExpression)*;

OpAdd:
	'+' | '-' | '|';

XPrimaryExpression returns xbase::XExpression:
	XConstructorCall |
	XBlockExpression |
	XSwitchExpression |
	XFeatureCall |
	XLiteral |
	XIfExpression |
//	XForLoopExpression |
	XWhileExpression |
//	XDoWhileExpression |
	XThrowExpression |
//	XReturnExpression |
	XTryCatchFinallyExpression |
	XParenthesizedExpression;
